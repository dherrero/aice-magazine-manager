{
  "version": 3,
  "sources": ["../../../../../../../apps/app-back/src/controllers/auth.controller.ts"],
  "sourcesContent": ["import HttpResponser from '@back/adapters/http/http.responser';\nimport { authService } from '@back/services';\nimport { NextFunction, Request, Response } from 'express';\nimport { TokenExpiredError } from 'jsonwebtoken';\n\nclass AuthController {\n  login = async (req: Request, res: Response) => {\n    try {\n      const { email, password, remember } = req.body;\n      const user = await authService.login(email, password);\n      const userData = {\n        id: user.id,\n        email: user.email,\n        permision: user.permission\n          ? user.permission.split(/[\\s,;]+/).filter(Boolean)\n          : [],\n        remember,\n      };\n      return this.#responseWithTokens(res, userData);\n    } catch (err) {\n      console.log(err);\n      return HttpResponser.errorJson(res, err);\n    }\n  };\n\n  hasPermission =\n    (permision?: string | string[]) =>\n    (req: Request, res: Response, next: NextFunction) => {\n      if (req.method === 'OPTIONS') {\n        next();\n      } else {\n        const token = req.header('Authorization');\n        const refreshToken = req.headers['refresh-token'] as string;\n        const randomCode = Math.floor(Math.random() * 1000);\n        if (!token || !refreshToken)\n          return HttpResponser.errorJson(\n            res,\n            { message: `Access denied code: ${randomCode}0` },\n            401\n          );\n        try {\n          const decode = authService.verifyToken(token);\n          res.locals.user = { ...decode };\n          if (permision && Array.isArray(permision)) {\n            if (!decode.permision)\n              return HttpResponser.errorJson(\n                res,\n                { message: `Access denied code: ${randomCode}1` },\n                401\n              );\n            const intersection = permision.filter((x) =>\n              decode.permision.includes(x)\n            );\n            if (!intersection.length)\n              return HttpResponser.errorJson(\n                res,\n                { message: `Access denied code: ${randomCode}2` },\n                401\n              );\n          } else if (permision) {\n            if (!decode.permision)\n              return HttpResponser.errorJson(\n                res,\n                { message: `Access denied code: ${randomCode}3` },\n                401\n              );\n            if (!decode.permision.includes(permision))\n              return HttpResponser.errorJson(\n                res,\n                { message: `Access denied code: ${randomCode}4` },\n                401\n              );\n          }\n          next();\n        } catch (error) {\n          if (error instanceof TokenExpiredError) {\n            return this.#refreshToken(req, res, next);\n          } else {\n            return HttpResponser.errorJson(\n              res,\n              { message: 'Invalid token' },\n              401\n            );\n          }\n        }\n      }\n    };\n\n  #refreshToken = async (req: Request, res: Response, next: NextFunction) => {\n    const refreshToken = req.headers['refresh-token'] as string;\n    if (!refreshToken) {\n      return HttpResponser.errorJson(\n        res,\n        { message: 'Access Denied. No refresh token provided.' },\n        401\n      );\n    }\n\n    try {\n      const decode = authService.verifyToken(refreshToken);\n      const user = await authService.getUser(decode.id);\n      const userData = {\n        id: user.id,\n        email: user.email,\n        remember: decode.remember,\n        permision: user.permission\n          ? user.permission.split(/[\\s,;]+/).filter(Boolean)\n          : [],\n      };\n      res.locals.user = { ...userData };\n      return this.#responseWithTokens(res, userData, next);\n    } catch (error) {\n      return HttpResponser.errorJson(res, { message: 'Invalid token' }, 401);\n    }\n  };\n\n  #responseWithTokens = async (\n    res: Response,\n    userData,\n    next?: NextFunction\n  ) => {\n    const accessToken = await authService.generateToken(\n      userData,\n      process.env.NODE_JWT_ACCESS_EXPIRES_IN || '4h'\n    );\n    res.setHeader('Authorization', accessToken);\n\n    if (!next) {\n      // If next is not defined, then it means that the request is a login request, so we need to send the refresh token\n      const refreshToken = await authService.generateToken(\n        { id: userData.id, remember: userData.remember },\n        userData.remember\n          ? '365d'\n          : process.env.NODE_JWT_REFRESH_EXPIRES_IN || '8h'\n      );\n      res.setHeader('Refresh-Token', refreshToken);\n      return HttpResponser.successEmpty(res);\n    }\n\n    next();\n  };\n}\nconst authController = new AuthController();\nexport default authController;\n"],
  "mappings": "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",
  "names": ["HttpResponser"]
}
